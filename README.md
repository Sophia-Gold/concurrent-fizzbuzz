# concurrent-fizzbuzz.clj
...your favorite demeaning technical interview question implemented with Clojure's core.async library.

Although the choice of content places it in a tongue-in-cheek lineage with those such as [TensorFlow fizz buzz](http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/) this began as an exercise for me to learn core.async, an implementation of Tony Hoare's [Communicating Sequential Processes](http://www.usingcsp.com/cspbook.pdf) almost exactly the same as that in Google's Go language. 

However, this concurrency pattern is really just about non-blocking infinite loops and CSP an ideal way to structure them. What  matters are you feed into the loops, and here I used Clojure's [transducers](http://clojure.org/reference/transducers) to generate a lazy sequence. This turned out to be so fast the concurrency loop actually slowed it down by a linear factor: still ~3,300μs ran in parallel compared to ~75μs (blazing fast!) using Clojure's transduce function, but enough that clearly this is just about demonstrating simple core.async structure and not efficiency. 

How are transducers so fast? First of all, they're higher-order functions that take advantage of the [catamorphic properties of folds](http://www.cs.nott.ac.uk/~pszgmh/fold.pdf) to create an abstraction barrier from the operations on which they'll be used (i.e. print, str, conj, etc.). This all might sound quite theoretical, but the real takeaway for the very few who actually care about fizz buzz is not only does Clojure beat most naive implementations in native languages, but that _by testing conditionals through catamorphic folds you can store them in a data structure and get printing for free_.